Unheard-of Velocity
in Complex Software
Twenty interconnected tools that enable multiple AI agents to work in parallel, review each other's work, and make incredible autonomous progress, all while you're away.
“The magic isn't in any single tool. It's in how they work together. Using three tools is 10x better than using one.”
6+
Parallel agents
8+
Projects simultaneously
2K+
GitHub stars
3+ hrs
Autonomous work
The Agentic Coding Flywheel
Twenty tools that create unheard-of velocity
Explore the Flywheel
Click a tool to see its connections and features
A self-reinforcing system that enables multiple AI agents to work in parallel across 10+ projects, reviewing each other's work, creating and executing tasks, and making incredible autonomous progress while you're away.
How the Tools Work Together
These aren't hypothetical scenarios. These are actual daily workflows running across 8+ projects with multiple AI agents.
Daily Parallel Progress
Keep multiple projects moving forward simultaneously, even when you don't have mental bandwidth for all of them.
Come back 3+ hours later to find incredible autonomous progress across all projects
Agents Reviewing Agents
Have your agents review each other's work to catch bugs, errors, and issues before they become problems.
Multiple agents catching each other's errors before they ship
5,500 Lines to 347 Beads
Transform massive planning documents into executable, dependency-tracked task graphs that agents can work through systematically.
Project nearly complete the same day, agents pushing commits while you're in bed
Fresh Eyes Code Review
Have agents deeply investigate code with fresh perspectives, finding bugs that humans miss.
Systematic, methodical bug discovery and correction
Multi-Repo Morning Sync
Start your day with all repos synced, agents spawned, and ready to execute tasks across the fleet.
Full fleet of repos synced and agents working before your first coffee is done
Bulk AI Commit Automation
Use RU's Agent Sweep to intelligently commit dirty repos across your entire fleet with AI-generated commit messages.
20+ repos committed with intelligent, contextual messages while you're away
Resource-Protected Agent Swarm
Run multiple heavy agents simultaneously without your workstation becoming unresponsive. SRPS keeps everything smooth.
Run 6+ heavy agents simultaneously without system lockup - SRPS keeps your UI snappy
The Prompts That Power the Workflow
Copy these prompts to your Stream Deck or command palette. Each takes under a second to execute with a single button press.
Deep Code Exploration
I want you to sort of randomly explore the code files in this project, choosing code files to deeply investigate and understand and trace their functionality and execution flows through the related code files which they import or which they are imported by. Once you understand the purpose of the code in the larger context of the workflows, I want you to do a super careful, methodical, and critical check with "fresh eyes" to find any obvious bugs, problems, errors, issues, silly mistakes, etc. and then systematically and meticulously and intelligently correct them.
When: When you want agents to find hidden bugs and understand the codebase deeply
Agent Peer Review
Ok can you now turn your attention to reviewing the code written by your fellow agents and checking for any issues, bugs, errors, problems, inefficiencies, security problems, reliability issues, etc. and carefully diagnose their underlying root causes using first-principle analysis and then fix or revise them if necessary? Don't restrict yourself to the latest commits, cast a wider net and go super deep!
When: After agents have been working independently, have them review each other
UX/UI Deep Scrutiny
I want you to super carefully scrutinize every aspect of the application workflow and implementation and look for things that just seem sub-optimal or even wrong/mistaken to you, things that could very obviously be improved from a user-friendliness and intuitiveness standpoint, places where our UI/UX could be improved and polished to be slicker, more visually appealing, and more premium feeling and just ultra high-quality, like Stripe-level apps.
When: When dissatisfied with UX but don't have energy to grapple with it directly
Comprehensive Beads Planning
OK so please take ALL of that and elaborate on it more and then create a comprehensive and granular set of beads for all this with tasks, subtasks, and dependency structure overlaid, with detailed comments so that the whole thing is totally self-contained and self-documenting (including relevant background, reasoning/justification, considerations, etc.-- anything we'd want our "future self" to know about the goals and intentions and thought process and how it serves the over-arching goals of the project.)
When: After generating improvement suggestions, turn them into actionable tasks
Plan Space Validation
Check over each bead super carefully-- are you sure it makes sense? Is it optimal? Could we change anything to make the system work better for users? If so, revise the beads. It's a lot easier and faster to operate in "plan space" before we start implementing these things!
When: Before executing a large batch of beads, validate the plan
Systematic Bead Execution
OK, so start systematically and methodically and meticulously and diligently executing those remaining beads tasks that you created in the optimal logical order! Don't forget to mark beads as you work on them.
When: After planning and validation, execute the work
Post-Implementation Review
Great, now I want you to carefully read over all of the new code you just wrote and other existing code you just modified with "fresh eyes" looking super carefully for any obvious bugs, errors, problems, issues, confusion, etc. Carefully fix anything you uncover.
When: After a batch of implementation work, review everything
Intelligent Commit Grouping
Now, based on your knowledge of the project, commit all changed files now in a series of logically connected groupings with super detailed commit messages for each and then push. Take your time to do it right. Don't edit the code at all. Don't commit obviously ephemeral files.
When: Final step after all work is done
Using Three Tools is 10x Better Than One
Each tool amplifies the others. The synergies compound over time.
The Core Loop
NTM spawns agents that register with Mail for coordination. They use BV to find tasks to work on. The result: autonomous agents that figure out what to do next without human intervention.
“Spawn 6 agents across 3 projects. Each finds work via BV, coordinates via Mail. You return 3 hours later to merged PRs.”
Collective Memory
CASS indexes all agent sessions for instant search. CM stores learnings as procedural memory. Together: agents that never repeat mistakes and always remember what worked.
“New agent asks 'how did we handle auth?' CASS finds the answer in 60ms. CM surfaces the playbook that worked.”
Safety Net
UBS catches bugs before they're committed. SLB prevents dangerous commands from running without approval. Together: aggressive automation with guardrails.
“Agent finds a bug, wants to `git reset --hard`. SLB requires a second agent to approve. UBS validates the fix before merge.”
Approval Workflow
SLB sends approval requests directly to agent inboxes via Mail. Recipients can review context and approve or reject. Fully auditable decision trail.
“Agent proposes database migration. SLB notifies reviewers via Mail. Second agent reviews diff, approves. Audit log preserved.”
Learned Patterns
BV tracks task patterns and completion history. CM stores what approaches worked. Together: each new task benefits from all past solutions.
“Similar bug appears in new project. CM surfaces the pattern. BV creates bead linking to successful prior fix.”
Account Orchestration
CAAM manages API keys for all your agent accounts. NTM spawns agents with the right credentials automatically. Seamless multi-account workflows.
“Rate limited on one Claude account? NTM spawns agents with fresh credentials from CAAM. No manual switching.”
Multi-Repo Orchestra
RU syncs all your repos with parallel workers. NTM spawns agents into each repo. BV tracks tasks across the entire fleet. Coordinated progress across dozens of projects.
“Morning: `ru sync -j4`. RU clones 3 new repos, pulls 15 updates. NTM spawns agents. By lunch, beads completed across 8 projects.”
Repo Coordination
RU agent-sweep can coordinate via Mail to prevent conflicts. Agents claim repos before committing. Complete audit trail of which agent touched which repo.
“Agent A claims repo-1, Agent B claims repo-2. Both run agent-sweep in parallel. No conflicts, clear ownership.”
Layered Safety Net
DCG blocks dangerous commands before execution. SLB provides a human-in-the-loop confirmation after Claude proposes risky operations. Together they create defense in depth - DCG catches obvious destructive patterns, SLB catches contextual risks that require human judgment.
“Claude proposes 'rm -rf ./old_code' - DCG blocks it instantly. Claude rephrases to 'mv ./old_code ./archive' - SLB prompts for confirmation before the move.”
Protected Agent Fleet
NTM spawns multiple Claude agents. Each agent runs under DCG protection. If one agent attempts something dangerous, DCG blocks it and can notify via Mail so other agents (or you) know what happened.
“Agent 1 working on repo cleanup tries 'git clean -fdx'. DCG blocks it. Mail notification: 'Agent 1 attempted blocked command in project-x'.”
All Twenty Flywheel Tools
Each tool installs in under 30 seconds. Written in Go, Rust, TypeScript, Python, and Bash.
Named Tmux Manager
Agent cockpit for multi-agent tmux sessions
Transform tmux into a multi-agent command center. Spawn Claude, Codex, and Gemini agents in named panes. Broadcast prompts to specific agent types. Persistent sessions survive SSH disconnects.
- Named agent panes with type classification
- Broadcast prompts to agent types
curl --proto '=https' --proto-redir '=https' -fsSL https://r...
MCP Agent Mail
Like Gmail for AI coding agents
A complete coordination system for multi-agent workflows. Agents register identities, send/receive messages, search conversations, and declare file reservations to prevent edit conflicts.
- Threaded messaging between AI agents
- Advisory file reservations
curl --proto '=https' --proto-redir '=https' -fsSL "https://...
Ultimate Bug Scanner
Pattern-based bug scanner with 1000+ detection rules
Custom AST-grep patterns detecting subtle bugs across 7+ languages. Designed to have false positives for AI agents to evaluate. Sub-5-second feedback loops. Perfect as pre-commit hook or agent post-processor.
- 1000+ built-in detection patterns
- Consistent JSON output format
curl --proto '=https' --proto-redir '=https' -fsSL "https://...
Beads Viewer
Graph-theory triage engine for task prioritization
Transforms task tracking with DAG-based analysis. Nine graph metrics, robot protocol for AI, time-travel diffing. Agents use BV to figure out what to work on next.
- PageRank-based issue prioritization
- Critical path analysis
curl --proto '=https' --proto-redir '=https' -fsSL "https://...
beads_rust
Local-first issue tracking for AI agents
Local-first issue tracking for AI agents. SQLite + JSONL hybrid: fast queries locally, git-friendly export for collaboration. Non-invasive - never auto-commits or touches source code.
- Local-first issue storage
- Dependency graph tracking
curl --proto '=https' --proto-redir '=https' -fsSL "https://...
Coding Agent Session Search
Blazing-fast search across AI coding agent sessions
Unified search for all AI coding sessions. Indexes Claude, Codex, Cursor, Gemini, ChatGPT, Cline, and more. Tantivy-powered <60ms prefix queries.
- Unified search across all agent types
- Sub-second search over millions of messages
curl --proto '=https' --proto-redir '=https' -fsSL https://r...
CASS Memory System
Procedural memory system for AI coding agents
Human-like memory for AI agents. Procedural playbooks, episodic session logs, semantic facts. Agents learn from experience and never repeat mistakes.
- Three memory layers: episodic, working, procedural
- MCP integration for any compatible agent
curl --proto '=https' --proto-redir '=https' -fsSL https://r...
Coding Agent Account Manager
Sub-100ms auth switching for AI coding agents
Manage multiple API keys for Claude, Codex, and Gemini. Sub-100ms account switching. Smart rotation with cooldown tracking. Encrypted credential bundles.
- Sub-100ms account switching
- Multi-provider support
curl --proto '=https' --proto-redir '=https' -fsSL "https://...
Simultaneous Launch Button
Two-person rule for dangerous command approval
Safety friction for autonomous agents. Three-tier risk classification. Cryptographic command binding with SHA-256+HMAC. Dynamic quorum. Complete audit trails.
- Two-person rule enforcement
- Command queue with approval workflow
curl --proto '=https' --proto-redir '=https' -fsSL https://r...
Destructive Command Guard
SIMD-accelerated safety net for dangerous commands
A Claude Code hook that blocks dangerous commands BEFORE they execute. Catches git resets, force pushes, rm -rf, DROP TABLE, and more. Fail-open design ensures you're never blocked by errors.
- Intercepts rm -rf, git reset --hard, etc.
- SIMD-accelerated pattern matching
curl --proto '=https' --proto-redir '=https' -fsSL https://r...
Repo Updater
Multi-repo sync with AI-driven commit automation
Synchronize dozens of GitHub repos with one command. AI-driven commit automation. Parallel workers, resume support, zero string parsing.
- One-command multi-repo sync
- Parallel operations
curl --proto '=https' --proto-redir '=https' -fsSL "https://...
Meta Skill
Skill management with MCP integration and adaptive suggestions
Store skills, search them, track effectiveness, package for sharing, and integrate with AI agents via MCP server. Skills come from hand-written files, CASS mining, bundles, or guided workflows.
- MCP server for native AI agent integration
- Thompson sampling optimizes suggestions
curl --proto '=https' --proto-redir '=https' -fsSL "https://...
Remote Compilation Helper
Transparent Rust build offloading to remote workers
Transparently offloads cargo builds to powerful remote machines. Your local machine stays cool while remote workers handle compilation. Seamless rsync integration.
- Transparent cargo interception
- Multi-worker pool with priority scheduling
curl --proto '=https' --proto-redir '=https' -fsSL "https://...
WezTerm Automata
Terminal hypervisor for multi-agent automation
Automates WezTerm terminal interactions. Send keystrokes, read screen content, manage panes and tabs programmatically. Perfect for agent orchestration.
- Real-time terminal observation
- Intelligent pattern detection
cargo install --git https://github.com/Dicklesworthstone/wez...
Brenner Bot
Research orchestration inspired by Sydney Brenner
Automates Brenner research methodology. Manages hypothesis slates, triangulated analysis, corpus mining, and systematic inquiry workflows.
- Primary source corpus with citations
- Multi-agent research sessions
curl --proto '=https' --proto-redir '=https' -fsSL "https://...
System Resource Protection Script
Auto-deprioritize background processes for responsive dev workstations
Installs ananicy-cpp with 1700+ rules to automatically deprioritize background processes, plus sysmoni TUI for real-time monitoring.
- Automatic process deprioritization
- Real-time TUI monitoring
curl -fsSL https://raw.githubusercontent.com/Dicklesworthsto...
Automated Plan Reviser Pro
Automated iterative spec refinement with extended AI reasoning
Takes rough plans and runs multiple review cycles using GPT Pro 5.2 Extended Reasoning via Oracle to identify architectural issues, edge cases, and security flaws.
- Automated multi-pass refinement
- Extended AI reasoning integration
curl -fsSL https://raw.githubusercontent.com/Dicklesworthsto...
JeffreysPrompts CLI
Browse and install battle-tested prompts as Claude Code skills
Official CLI for jeffreysprompts.com - browse curated prompts and install them as Claude Code skills with one command.
- One-command skill installation
- Browsable prompt categories
git clone https://github.com/Dicklesworthstone/jeffreyspromp...
Process Triage
Intelligent process termination with Bayesian scoring
Rust-based process manager with Bayesian scoring to identify and terminate problematic processes. TUI for interactive selection.
- Intelligent process scoring
- Interactive TUI selection
cargo install --git https://github.com/Dicklesworthstone/pro...
X Archive Search
Ultra-fast search over X/Twitter data archives
Hybrid BM25 + semantic search over X/Twitter data exports. Zero-dependency local processing with Reciprocal Rank Fusion.
- Sub-second search over large archives
- Semantic + keyword hybrid search
curl -fsSL https://raw.githubusercontent.com/Dicklesworthsto...
Built From Daily Experience
Unix Philosophy
Each tool does one thing well. They compose through JSON, MCP, and Git.
Agent-First
Every tool has --robot mode. Designed for AI agents to call programmatically.
Self-Reinforcing
The flywheel effect: each tool makes the others more powerful.
Battle-Tested
Born from daily use with 3+ AI agents on production codebases.
Ready to 10x Your Velocity?
The Agent Flywheel installer sets up all flywheel tools automatically. From zero to multi-agent workflows in 30 minutes.